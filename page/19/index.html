<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://www.hanumoka.net').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

<!-- 구글 애드센스 코드  -->
<script data-ad-client="ca-pub-6388187282606796" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-6388187282606796",
          enable_page_level_ads: true
     });
</script>
-->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-100596920-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-100596920-1');
</script>
 
<!-- 네이버 웹 마스터-->
<meta name="naver-site-verification" content="74bc91ee61c53c02f7d87ab3a442f99823f4f5f9">
  <meta name="description" content="아마추어 개발자의 블로그">
<meta property="og:type" content="website">
<meta property="og:title" content="Hanumoka, IT Blog">
<meta property="og:url" content="https://www.hanumoka.net/page/19/index.html">
<meta property="og:site_name" content="Hanumoka, IT Blog">
<meta property="og:description" content="아마추어 개발자의 블로그">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="Hanumoka">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.hanumoka.net/page/19/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Hanumoka, IT Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Hanumoka, IT Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hanumoka, IT Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">그래봐야 코딩, 그래도 코딩</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>홈</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>태그</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>카테고리</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>아카이브</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-fw fa-calendar"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>Sitemap</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-fw fa-rss"></i>rss</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>Commonweal 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>검색
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Searching..." spellcheck="false" type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/hanumoka" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="external nofollow noopener noreferrer" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://www.hanumoka.net/2017/09/10/java-20170910-java-arbitrary-number-of-arguments/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hanumoka">
      <meta itemprop="description" content="아마추어 개발자의 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hanumoka, IT Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/10/java-20170910-java-arbitrary-number-of-arguments/" class="post-title-link" itemprop="url">java arbitrary number of arguments(...함수매개변수)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2017-09-10 15:42:25" itemprop="dateCreated datePublished" datetime="2017-09-10T15:42:25+09:00">2017-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-04-16 01:50:11" itemprop="dateModified" datetime="2020-04-16T01:50:11+09:00">2020-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/20170910-java-arbitrary-number-of-arguments.jpg" alt="tips"><br>java의 함수에는 일반적으로 동일한 자료형의 여러개 데이터를 인자로 받을 때, 배열을 인자로 사용 할 수 있다. 하지만 arbitrary number of arguments(… 함수인자)를 사용할 경우 함수는 배열보다도 유연하게 인자를 받을 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ... values)</span></span>&#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>위와 같은 <strong>자료형 … 매개변수명</strong> 형태로 함수의 인자를 선언 할 수 있다. 예제를 보면 쉽게 이해가 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int형의 파라미터가 몇개가 넘어올지 모를 경우, 대응 할 수 있는 ... 확장된 배열형태의 매개변수 형태</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ... values)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//배열로 인자에 접근 할 수 있다.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; values.length; i++)&#123;</span><br><span class="line">      total += values[i];</span><br><span class="line">    &#125;<span class="comment">// for</span></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">  &#125;<span class="comment">// sum</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//인자를 아예 안받을 수도 있다.</span></span><br><span class="line">    System.out.println(sum());     <span class="comment">// 결과: 0 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//인자를 하나만 받을 수 있다.</span></span><br><span class="line">    System.out.println(sum(<span class="number">1</span>));     <span class="comment">// 결과: 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//물론 3개도 된다.</span></span><br><span class="line">    System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 결과: 6</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//배열로도 받을 수 있다.</span></span><br><span class="line">    System.out.println(sum(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;)); <span class="comment">// 결과: 10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] values = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    System.out.println(sum(values)); <span class="comment">// 결과: 15</span></span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>함수를 선언 할때 *<em>동일한 형태의 자료형의 인자가 0개 또는 n가 예상 되거나, 또는 배열형태의 인자가 예상될 경우 *</em>함수 오버로딩을 대신하여 위의 arbitrary number of arguments 사용하면 편 할 것 같다. </p>
<p>다만 주의 할 점은 <strong>arbitrary number of arguments(… 함수인자)를 사용한 경우 해당 함수는 다른 인자는 갖을 수 없다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ... values, <span class="keyword">int</span> b)</span></span>&#123;...&#125;;  <span class="comment">// 컴파일 오류</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ... values, String b)</span></span>&#123;...&#125;; <span class="comment">// 컴파일 오류</span></span><br></pre></td></tr></table></figure>


      
      
          
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>

  
      


  
  
  
  

        
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://www.hanumoka.net/2017/09/10/java-20170910-java-this-constructor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hanumoka">
      <meta itemprop="description" content="아마추어 개발자의 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hanumoka, IT Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/10/java-20170910-java-this-constructor/" class="post-title-link" itemprop="url">java this() 생성자</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2017-09-10 14:22:46" itemprop="dateCreated datePublished" datetime="2017-09-10T14:22:46+09:00">2017-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-04-16 01:50:11" itemprop="dateModified" datetime="2020-04-16T01:50:11+09:00">2020-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/20170910-java-this-constructor.png" alt><br>이번에 기록할 내용은 this생성자 이다. (this 키워드가 아니다.)<br>java의 클래스 생성자도 역시 오버로딩이 가능하다. 함수 오버로딩은 훌륭한 기능이다. 다만 일반 함수의 오버로딩이 아니라 생성자의 오버로딩일 경우 객체의 멤버변수를 셋팅하는 경우가 많기 때문에 중복된 소스가 자주 발생한다. </p>
<p>this() 생성자란 클래스의 생성자 오버로딩시 반복되는 소스를 줄여주는 훌륭한 방법이다.<br>생성자 내부의 코드 블록 첫줄에 this()를 호출함으로 자신의 다른 생성자를 호출 할 수 있다. <strong>주의할 점은 생성자 코드블록 내부의 this() 위에 다른 소스코드가 존재해서는 안된다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"> <span class="keyword">private</span> String sex;</span><br><span class="line">	</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">  <span class="comment">//this.name = name;  // this()생성자 위에 있는 코드에는 컴파일 오류가 발생한다.</span></span><br><span class="line"> <span class="keyword">this</span>(name, <span class="number">12</span>);  <span class="comment">//자동으로 해당 파라미터에 적합한 자신의 생성자를 호출한다.</span></span><br><span class="line"> System.out.println(<span class="string">"this생성자 아래에는 다른 코드가 존재 할 수 있다."</span>);</span><br><span class="line"> &#125;</span><br><span class="line">	</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"> <span class="comment">//this.name = name;  // this()생성자 위에 있는 코드에는 컴파일 오류가 발생한다.</span></span><br><span class="line"> <span class="comment">//this.age = age;    // this()생성자 위에 있는 코드에는 컴파일 오류가 발생한다.</span></span><br><span class="line"> <span class="keyword">this</span>(name, age, <span class="string">"Man"</span>);  <span class="comment">//자동으로 해당 파라미터에 적합한 자신의 생성자를 호출한다.</span></span><br><span class="line"> System.out.println(<span class="string">"this생성자 아래에는 다른 코드가 존재 할 수 있다."</span>);</span><br><span class="line"> &#125;</span><br><span class="line">	</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String sex)</span></span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> <span class="keyword">this</span>.age = age;</span><br><span class="line"> <span class="keyword">this</span>.sex = sex;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 예제소스를 보면 쉽게 이해가 될것이다. 편리한 기능이라 생각되어 이렇게 기록해 놓는다. </p>

      
      
          
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>

  
      


  
  
  
  

        
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://www.hanumoka.net/2017/09/08/java-20170908-java-NaN-Infinity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hanumoka">
      <meta itemprop="description" content="아마추어 개발자의 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hanumoka, IT Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/08/java-20170908-java-NaN-Infinity/" class="post-title-link" itemprop="url">java 고통의 NaN Infinity</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2017-09-08 14:33:46" itemprop="dateCreated datePublished" datetime="2017-09-08T14:33:46+09:00">2017-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-04-16 01:50:11" itemprop="dateModified" datetime="2020-04-16T01:50:11+09:00">2020-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java에서 / 또는 % 연산자를 사용할 때, 제수가 정수 0인 경우 RuntimeException 중 하나인 ArithmeticException 발생한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">int</span> z = x / y;</span><br><span class="line">  <span class="keyword">int</span> z = x % y;</span><br><span class="line">  System.out.println(<span class="string">"z:"</span> + z);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">  e.printStackTrace();  <span class="comment">// 다음과 같은 예외 발생: java.lang.ArithmeticException: / by zero</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>문제는 / 또는 % 연산자를 사용할 때, 제수가 정수 0이 아닌 <strong>실수 0.0 또는 0.0f인</strong> 경우이다. 이때는 ArithmeticException이 발생하는 것이 아니라, <strong>Infinity(무한)</strong>, <strong>NaN(Not a Number)</strong>라는 값이 발생한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">3</span> / <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">5</span> % <span class="number">0.0</span>;</span><br><span class="line">		</span><br><span class="line">System.out.println(a);   <span class="comment">// 결과 : Infinity</span></span><br><span class="line">System.out.println(b);   <span class="comment">// 결과 : NaN</span></span><br><span class="line"></span><br><span class="line">System.out.println(a + <span class="number">12</span>); <span class="comment">// 결과 : Infinity</span></span><br><span class="line">System.out.println(b * <span class="number">6</span>);  <span class="comment">// 결과 : NaN</span></span><br></pre></td></tr></table></figure>

<p>수학적으로 오류가 발생해야 하는 것임에도 ArithmeticException가 발생하지 않는다. 거기다 a, b변수는 double의 자료형임에도 Infinity, NaN 이라는 문자열 형태 데이터가 출력된다.(잘은 모르겠으나, Double wrapper 클래스가 개입하는 것이라고 개인적으로 추측해본다.)<br>거기다 이 Infinity, NaN는 오라클의 null 값과 비슷 한 특성을 가지고 있다. 오라클의 null에 어떤 연산을 가하면 미지의 쓰레기 값이 발생하는데, 이 java에서의 Infinity, NaN에 어떤 추가적 산술연산을 할경우 Infinity는 계속 Infinity가 되며 NaN도 계속 NaN이 된다.</p>
<p>Double.isInfinite(a)와 Double.isNaN(b)를 이용하여 Infinity와 NaN를 값을 확인 할 수 있다. 따라서 다음과 같이 Infinity, NaN을 방어하는 코드를 만들수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Double.isInfinite(a) || Double.isNaN(a))&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>하지만 애시당초 0.0 또는 0.0f와 같은 값들을 정수 0로 치환하여 / 또는 % 연산시 자동으로 ArithmeticException가 발생하게 하는 편이 더 편할 것 같다.</p>
<p>마지막으로 Infinity, NaN에 관련하여 생각해야할 문제점이 있다. 그것은 Double.valueOf(x)의 멍청함이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> val = Double.valueOf(<span class="string">"NaN"</span>);    <span class="comment">// 오류가 나지 않고 NaN값이 저장된다.</span></span><br><span class="line"><span class="keyword">double</span> val2 = Double.valueOf(<span class="string">"Infinity"</span>);  <span class="comment">// 오류가 나지 않고 Infinity값이 저장된다.</span></span><br><span class="line">		</span><br><span class="line"><span class="keyword">double</span> foo1 = <span class="number">1000.0</span>;</span><br><span class="line"><span class="keyword">double</span> foo2 = <span class="number">1000.0</span>;</span><br><span class="line">		</span><br><span class="line">foo1 += val;</span><br><span class="line">foo2 += val2;</span><br><span class="line">		</span><br><span class="line">System.out.println(foo1);  <span class="comment">// 결과 NaN</span></span><br><span class="line">System.out.println(foo2);  <span class="comment">// 결과 Infinity</span></span><br></pre></td></tr></table></figure>
<p>위 예제를 보면 Double.valueOf의 인자로 <strong>문자열 NaN, Infinity</strong>를 받는다. 하지만 코드를 실행시 어떠한 오류없이 동작하며 콘솔에는 NaN, Infinity가 출력된다. 재앙이 아닐 수 없다.</p>
<p><img src="/images/20170908-java-NaN-Infinity.jpg" alt></p>
<p>정리하자면<br><strong>java의 산술식에서 0.0또는 0.0f같은 값은 정수 0으로 치환하는 편이 좋아보이며, Double.valueOf함수를 사용시 반드시 Double.isInfinite, Double.isNaN를 통하여 후처리를 해줘야 할 것 같다.</strong></p>

      
      
          
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>

  
      


  
  
  
  

        
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://www.hanumoka.net/2017/09/08/java-20170908-java-floating-point-issue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hanumoka">
      <meta itemprop="description" content="아마추어 개발자의 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hanumoka, IT Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/08/java-20170908-java-floating-point-issue/" class="post-title-link" itemprop="url">java floating point issue(부동소수점 산술 시 문제점)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2017-09-08 07:34:48" itemprop="dateCreated datePublished" datetime="2017-09-08T07:34:48+09:00">2017-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-04-16 01:50:11" itemprop="dateModified" datetime="2020-04-16T01:50:11+09:00">2020-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/20170908-java-floating-point-issue.jpg" alt="부동소수점"></p>
<h3 id="부동소수점"><a href="#부동소수점" class="headerlink" title="부동소수점"></a>부동소수점</h3><p>코딩을 공부하다보면, 누구나 마주해야할 최악의 적! floating point! 이것은 자바언어의 문제가 아니라 컴퓨터의 자체적인 문제로 실수의 표현 및 계산 시 오차의 원인이 되는 이유이다.<br>간단히 말해 자바는 실수표현을 부동소수점을 이용하기 때문에 정확한 실수를 저장 할 수 없으며, 최대한 완벽에 가깝기를 바라는 근사치 값을 저장한다.</p>
<p><a href="https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90#.EC.A0.95.ED.99.95.EB.8F.84_.EB.AC.B8.EC.A0.9C" target="_blank" rel="external nofollow noopener noreferrer">부동소수점의 정확도 문제(위키)</a></p>
<hr>
<h4 id="부동소수점-산술시-문제"><a href="#부동소수점-산술시-문제" class="headerlink" title="부동소수점 산술시 문제"></a>부동소수점 산술시 문제</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//예제1: 부동소수점 산술시 문제점</span></span><br><span class="line"><span class="keyword">int</span> apple = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> piceUnit = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">7</span>;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">double</span> result = apple - number * piceUnit;  <span class="comment">// 원하는 계산:  1 - 7 * 0.1 = 0.3</span></span><br><span class="line">System.out.println(result); <span class="comment">// 결과 : 0.29999999999999993</span></span><br></pre></td></tr></table></figure>
<p>1 - 7 * 0.1 산술식의 정확한 계산은 0.3이다. 하지만 결과는 0.29999999999999993 이다. 원인은 double이라는 실수형 자료형이 0.1을 정확히 표현하지 못하기 때문이다. 정말 성가신 녀셕이 아닐 수 없다.</p>
<p>따라서 실수의 정확한 계산을 위한 한가지 방법으로는 정수형태로 계산을 한 뒤, 소수점을 나중에 반영하는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//예제2: 부동소수점 산술시 문제점 해결방법</span></span><br><span class="line"><span class="keyword">int</span> apple = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> totalPieces = apple * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> temp = totalPieces - number;</span><br><span class="line">		</span><br><span class="line"><span class="keyword">double</span> result = temp / <span class="number">10.0</span>;   <span class="comment">// 이런식으로 나중에 소수점 만큼의 계산 결과에 나눠준다.</span></span><br><span class="line">System.out.println(result);  <span class="comment">// 결과 : 0.3</span></span><br></pre></td></tr></table></figure>
<p>만약 자바를 이용해서 계산기 같은 것을 만든다면, 위와 같은 부동수수점 산술시에 실수들을 정수형태로 변형해서 계산하는 것을 고려해볼 필요가 있다.</p>
<hr>
<h4 id="double과-float의-비교연산시-문제"><a href="#double과-float의-비교연산시-문제" class="headerlink" title="double과 float의 비교연산시 문제"></a>double과 float의 비교연산시 문제</h4><p>float는 4바이트 실수, double은 8바이트 실수 값을 저장 할 수 있다. 부동소수점으로 실수를 표현하기 때문에 double은 float보다 상대적으로 보다 더 정확한 실수를 표현 할 수 있다.<br>문제는 1미만의 값을 갖는 double과 float간의 정확도 차이이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1.0</span> == <span class="number">1.0f</span>);  <span class="comment">// 결과 : true</span></span><br><span class="line">System.out.println(<span class="number">1.1</span> == <span class="number">1.1f</span>);  <span class="comment">// 결과 : false</span></span><br><span class="line">System.out.println(<span class="number">0.1</span> == <span class="number">0.1f</span>);  <span class="comment">// 결과 : false</span></span><br><span class="line">System.out.println(<span class="number">0.9</span> == <span class="number">0.9f</span>);  <span class="comment">// 결과 : false</span></span><br><span class="line">System.out.println(<span class="number">0.01</span> == <span class="number">0.01f</span>);  <span class="comment">// 결과 : false</span></span><br></pre></td></tr></table></figure>
<p>위 예제를 눈으로면 보면 다 true일 것이라 착각 하기 쉽다. 하지만 주석처럼 맨 윗줄만 제외하고 다 false를 출력한다. 이유는 눈에 보이지는 않지만 float와 double자료형의 실수 표현의 정밀도의 차이가 발생하기 때문이다. 따라서 <strong>double과 float값을 비교 할때에는 모두 float로 형변환 하거나 정수로 변환하여 비교해야 한다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println((<span class="keyword">float</span>)<span class="number">1.1</span> == <span class="number">1.1f</span>);  <span class="comment">// 결과 : true</span></span><br><span class="line">System.out.println(<span class="number">0.1</span> == (<span class="keyword">double</span>)<span class="number">0.1f</span>);  <span class="comment">// 결과 : false</span></span><br><span class="line">System.out.println(<span class="number">0.1f</span> == (<span class="keyword">double</span>)<span class="number">0.1f</span>);  <span class="comment">// 결과 : true</span></span><br></pre></td></tr></table></figure>
<p>주의 할 점은 0.1f를 double로 형변환 하여 비교해도 될 거라 생각 할 수 있는데, (double)0.1f는 double의 공간에 float의 정밀도를 갖는 값이 저장될 뿐이다. 따라서 double형의 0.1과 비교해도 결과가 true로 나올 수 없다. </p>

      
      
          
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>

  
      


  
  
  
  

        
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://www.hanumoka.net/2017/09/08/java-20170908-java-datatype-orverlow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hanumoka">
      <meta itemprop="description" content="아마추어 개발자의 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hanumoka, IT Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/08/java-20170908-java-datatype-orverlow/" class="post-title-link" itemprop="url">java datatype overflow(데이터 오버플로어)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2017-09-08 06:09:18" itemprop="dateCreated datePublished" datetime="2017-09-08T06:09:18+09:00">2017-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-04-16 01:50:11" itemprop="dateModified" datetime="2020-04-16T01:50:11+09:00">2020-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>java언어에서는 datatype(자료형)이라는 것이 존재한다.<br>자료형이란 변수에 저장 될 데이터의 형태를 지정하는 용도로 사용되며, 정수 실수 문자 논리 등등 다양한 형태로 존재한다. datatype overflow란 이 java에서 산술연산을 할 경우 해당 변수의 자료형의 표현 범위를 초과할 경우 쓰레기값이 발생되는 경우를 말한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//예제1</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> c = a * b;</span><br><span class="line">System.out.println(c);  <span class="comment">// 결과 : -727379968</span></span><br></pre></td></tr></table></figure>
<p>정수형 int 변수 c에는 1000000000000 이라는 값이 저장되는 것이 아니라, -727379968라는 예상치 못한 값이 저장된다.<br>그 이유는 int가 표현할수 있는 정수값의 범위에 1000000000000 와 같이 큰 정수값이 저장될수 없기 때문이다.<br>java의 자료형 범위는 다음과 같다.</p>
<p><img src="/images/20170908-java-datatype-overflow.png" alt="data overflow"></p>
<p>따라서 예제1의 경우 int보다 큰 long자료형을 사용하여 해결 할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//예제2</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">long</span> c = a * b;  </span><br><span class="line">System.out.println(c);  <span class="comment">// 결과 : -727379968</span></span><br></pre></td></tr></table></figure>
<p>최종으로 연산된 값이 저장될 c변수의 자료형을 int보다 큰 long으로 변경 했음에도 여전히 값은 -727379968라는 쓰래기 값이 저장된다. 실수하기 쉬운 부분인데 c는 long 타입이지만 c에 피연자인 a, b는 여전히 int이므로 결과적으로 c에는 예제1과 마찬가지로 쓰레기 값이 저장된다.<br>따라서 산술식의 피연산자중 최소 한개는 long 타입이어야 올바른 계산이 된다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//예제3</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">long</span> c = (<span class="keyword">long</span>)a * b;  </span><br><span class="line">System.out.println(c);  <span class="comment">// 결과 : 1000000000000</span></span><br></pre></td></tr></table></figure>
<p>산술로직을 사용할 경우 위와 같은 문제를 방어하기 위한 전용 산술 함수를 사용하는 편이 코딩에 효과 적일 것 같다.</p>

      
      
          
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>

  
      


  
  
  
  

        
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://www.hanumoka.net/2017/09/07/web-20170907-markdown1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hanumoka">
      <meta itemprop="description" content="아마추어 개발자의 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hanumoka, IT Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/07/web-20170907-markdown1/" class="post-title-link" itemprop="url">마크다운(markdown)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2017-09-07 07:12:18" itemprop="dateCreated datePublished" datetime="2017-09-07T07:12:18+09:00">2017-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-04-16 01:50:12" itemprop="dateModified" datetime="2020-04-16T01:50:12+09:00">2020-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="마크다운이란"><a href="#마크다운이란" class="headerlink" title="마크다운이란"></a>마크다운이란</h3><p>간단히 말해서 웹 문서 전용 글쓰기 마크업 언어이다. 웹에서 보여질 심플한 문서(대표적으로 HTML)를 간편하고 쉽게 작성하기 위해 만들어진 마크업 언어이다. 일반적으로 웹 페이지를 만들기 위해서는 HTML언어를 사용해야 한다.</p>
<p>코딩 할 때 개인적으로 순수 HTML의 명료성을 좋아하지만, 단순한 글을 쓰기위한 목적으로 쓰기에는 너무 많은 수고가 발생한다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>간단한 문서<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">H1</span>&gt;</span>간단한 문서를 써보자<span class="tag">&lt;/<span class="name">H1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">아이고 몇줄 쓰는데 온 갖 태그를 타이핑 해야 된다. 힘들당<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">"3"</span>&gt;</span>WYSIWYG에디터라도 있었으면...<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>마크다운은 몇 개의 특수문자를 이용한 간단한 문법을 이용하여, html로 변환할 수 있는 문서를 작성할 수 있다. 물론 html도 간단한 문법을 가지고 있지만, 마크다운에 비할바는 아니다. 마크다운을 한번 써보면 누구나 느낄 것이다. 사람 손으로 키보드에서 타이핑 하기가 정말 편하다. 물론 간단한 문법이기 때문에 HTML의 일부분 기능만 사용 할 수 있다. 하지만 내가 원하는 간단한 글쓰기 용으로는 부족해 보이지 않는다.</p>
<p><strong>마크다운 문서 -&gt; 마크다운 변환기 -&gt; HTML 문서</strong></p>
<p>내가 이 마크다운을 접하게 된 계기는 Jekyll, hexo등의 정적 블로그 프레임워크를 만들면서였다. 블로그에서 간단한 문서를 작성하는 방법으로 jekyll, hexo, ghost 등의 블로그 프레임워크에서 마크다운을 지원하고 있다.</p>
<p>네이버블로그, 티스토리등에서 지원하는 WYSIWYG에디터는 웹에서 간편하게 글을 쓸수 있지만, 그 것으로 작성되어 변환된 HTML은 지옥의 죄수들을 갈아놓은 스프와 같아보였다. 거기다 WYSIWYG에디터에서 소스코드등을 삽입하기 위해서는 플러그인또는 js를 건드려야 한다.</p>
<p>반면 마크다운으로 작성된 문서의 HTML은 상대적으로 심플하며, 자체적으로 제공하는 심플한 문법으로 소스코드 삽입이 아주 편하다. Typora라는 마크다운 에디터를 사용하면, 마크다운의 문법의 러닝커브도 상당히 줄어든다.</p>
<hr>
<h3 id="마크다운-에디터-Typora"><a href="#마크다운-에디터-Typora" class="headerlink" title="마크다운 에디터(Typora)"></a>마크다운 에디터(Typora)</h3><p>마크다운문서도 문서의 종류일 뿐이다. 메모장으로 작성해도 되지만, 요즘 세상에 편리한 툴을 두고 고생을 하는 것는 인생을 낭비하기에 딱 좋은 방법일 뿐 이다.</p>
<p>마크다운문서는 html로 변환되어야 할 기초 문서이다. 따라서 현재 내가 적성하고 있는 마크다운 문서를 html로 변환하고 또는 실시간으로 그 변화된 모습을 보여주는 기능이 있는 에디터가 필요했다.</p>
<p><img src="/images/20170907-markdown1.png" alt="아톰에디터 마크다운 작성화면"></p>
<p>위 화면은 아톰에디터에서 마크다운 플러그인을 설치하여 마크다운을 작성하는 화면이다. 아톰도 나름 쓸만했지만, 낮은 신뢰도와 너무 무거웠다. 그리고 한 화면에 마크업문서와 변환문서가 같이 보이므로 화면이 너무 좁아져서 불편한 감이 있었다.</p>
<p>그러다 찾게 된 마크다운 에디터는 Typora였다. Typora의 가장 큰 장점은 마크다운 문서를 작성하는 동시에 HTML로 변환된다는 것이다. <strong>한 화면에서!</strong> 거기다 간한단 단축키, 단축메뉴에서 마크다운 문법을 UI에서 지원하므로 나처럼 마크다운 문법이 생소한 경우 손쉽게 문서를 작성할 수 있다.</p>
<p>개인적으로 <strong>Typora = markdown계의 WYSIWYG에디터</strong> 이런 느낌이다. Windows, Mac, Linux모두 지원하므로 만약 마크다운을 입문하는 사람들에게는 Typora에디터를 추천한다.<br><a href="https://typora.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Typora">Typora홈페이지</a></p>
<hr>
<h3 id="마크다운-기본문법"><a href="#마크다운-기본문법" class="headerlink" title="마크다운 기본문법"></a>마크다운 기본문법</h3><p><a href="https://ko.wikipedia.org/wiki/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4" target="_blank" rel="external nofollow noopener noreferrer" title="마크다운 위키">마크다운 위키</a></p>

      
      
          
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>

  
      


  
  
  
  

        
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://www.hanumoka.net/2017/08/31/apache-20170831-apache-install-windows/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hanumoka">
      <meta itemprop="description" content="아마추어 개발자의 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hanumoka, IT Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/31/apache-20170831-apache-install-windows/" class="post-title-link" itemprop="url">apache웹서버 윈도우에 설치하기</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2017-08-31 03:09:49" itemprop="dateCreated datePublished" datetime="2017-08-31T03:09:49+09:00">2017-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-04-16 01:50:11" itemprop="dateModified" datetime="2020-04-16T01:50:11+09:00">2020-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/apache/" itemprop="url" rel="index">
                    <span itemprop="name">apache</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="아파치-Apache-웹서버-윈도우10-환경에-설치"><a href="#아파치-Apache-웹서버-윈도우10-환경에-설치" class="headerlink" title="아파치(Apache) 웹서버 윈도우10 환경에  설치"></a>아파치(Apache) 웹서버 윈도우10 환경에  설치</h3><p>windows10 64bit 운영체제에 아파치 웹서버를 설치하는 방법을 설명하겠다.</p>
<br>
1. 웹 브라우저를 통해 https://www.apachelounge.com/download/ 로 이동
>![](/images/2017-06-11-apache설치_1.png)
원하는 아파치 웹서버 버전을 선택후 64bit zip 파일을 클릭하여 다운받는다.
>![](/images/2017-06-11-apache설치_2.png)


<ol start="2">
<li>해당 파일을 C:\ 경로로 이동후 압축을 푼다.<blockquote>
<p><img src="/images/2017-06-11-apache%EC%84%A4%EC%B9%98_3.png" alt><br>폴더 내부로 이동하여 Apache24 폴더를 잘라내기 한 후 다시 C:\ 경로로 이동하여 붙여넣기 한다.</p>
</blockquote>
</li>
</ol>
<p>최종적으로 아래와 같이 폴더 구성이 되면 된다.</p>
<blockquote>
<p><img src="/images/2017-06-11-apache%EC%84%A4%EC%B9%98_4.png" alt></p>
</blockquote>
<ol start="3">
<li>아파치 웹서버 설치전 환경 설정<blockquote>
<p><img src="/images/2017-06-11-apache%EC%84%A4%EC%B9%98_5.png" alt></p>
</blockquote>
</li>
</ol>
<p>C:\Apache24\conf 경로로 이동하여 httpd.conf 파일을 수정해야 한다.<br>파일을 메모장으로 연뒤 원하는 항목을 수정하면 되는데 여러 항목중에 다음 항목들이 중요하다.</p>
<blockquote>
<p>기본셋팅<br>ServerRoot “c:/Apache24”<br>Listen 80<br>DocumentRoot “c:/Apache24/htdocs”</p>
</blockquote>
<p>ServerRoot 항목은 기본적으로 “c:/Apache24” (경로 구분을 역슬래시로 해야 한다.) 되어 있다. 이 디폴트 셋팅을 그대로 사용하기 위해서 2번처럼 폴더 경로를 지정한 것이다. 만약 위 설명과 다른 폴더경로에 웹서버 폴더를 셋팅 했다면 ServerRoot 항목의 셋팅을 알맞게 수정해 주면 된다.</p>
<p>Listen 항목은 웹서버의 포트(port)설정이다. 웹서버는 기본적으로 80포트이다.(디폴트라 생략이 가능하다. <a href="http://www.naver.com" target="_blank" rel="external nofollow noopener noreferrer">www.naver.com</a> 와 <a href="http://www.naver.com:80" target="_blank" rel="external nofollow noopener noreferrer">www.naver.com:80</a> 은 같다)<br>원하는 포트가 있다면 역시 수정하라. (필자는 8080으로 수정하였다. )</p>
<p>DocumentRoot 항목은 웹서버에서 실행할 웹사이트 root 폴더를 지정해야 한다. ServerRoot처럼 디폴트로 “c:/Apache24/htdocs”로 셋팅 되어 있다.<br>원하는 경로가 있다면 수정하라.<br>부연설명으로 웹서버 기본 url(현재는 <a href="http://localhost:80" target="_blank" rel="external nofollow noopener noreferrer">http://localhost:80</a>) 접근시 웹서버는 DocumentRoot 에 설정된 폴더 내부의 index.html 를 디폴트로 리다이렉트 한다.</p>
<ol start="4">
<li>설치<br>관리자 모드로 cmd(명령 프롬프트) 창을 연다.<br>키보드의 윈도우 버튼을 누른뒤 cmd라고 검색하면 나온다.<br>명령 프롬프트 항목에 마우스 우클릭 한 뒤 “관리자 권한으로 실행”을 선택한다.<blockquote>
<p><img src="/images/2017-06-11-apache%EC%84%A4%EC%B9%98_6.png" alt></p>
</blockquote>
</li>
</ol>
<p>cmd 창이 열리면 cd C:\Apache243\bin 을 입력하여 경로를 이동한다.</p>
<p>이동한뒤 아래 명령어를 입력하여 아파치 서버를 설치한다.<br>httpd.exe -k install</p>
<p>뭔가 error라고 나오긴 하는데 무시해도 지장 없다.(도메인 관련 error 인것 같다)</p>
<p>만약 설치한 아파치 서버를 삭제 하고 싶다면 아래 명령어를 입력하면 된다.<br>httpd.exe -k uninstall</p>
<ol start="5">
<li>httpd.exe -k install  명령어 입력 후<blockquote>
<p><img src="/images/2017-06-11-apache%EC%84%A4%EC%B9%98_7.png" alt></p>
</blockquote>
</li>
</ol>
<p>윈도우 탐색기에서 C:\Apache24\bin 경로로 이동후 AapcheMonitor 응용 프로그램을 실행한다.</p>
<p>윈도우의 오른쪽 하단 작업 표시줄을 보면 ApacheMonitor가 실핼된 것을 확인 할수 있다.</p>
<blockquote>
<p><img src="/images/2017-06-11-apache%EC%84%A4%EC%B9%98_8.png" alt></p>
</blockquote>
<p>해당 아이콘을 우클릭후 Apache2.4 &gt; Start 를 클릭하면 웹서버가 동작한다.<br>반대로 웹서버를 종료하고 싶다면 Stop 을 클릭하면 된다.</p>
<ol start="6">
<li>웹서버 동작 확인</li>
</ol>
<p>웹서버를 start 한뒤에 인터넷 브라우저 창을 열고 주소창에</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:설정한포트번호</span><br></pre></td></tr></table></figure>
<p>또는 </p>
<pre><code>http://127.0.0.1:설정한포트번호 </code></pre><p>를 입력한다.</p>
<p>필자는 http.conf 파일에서 포트를 8080 으로 수정하였으므로</p>
<p><a href="http://localhost:8080" target="_blank" rel="external nofollow noopener noreferrer">http://localhost:8080</a> 을 입력하겠다.</p>
<blockquote>
<p><img src="/images/2017-06-11-apache%EC%84%A4%EC%B9%98_9.png" alt></p>
</blockquote>
<p>위처럼 DocumentRoot 경로의 index.html 브라우저창에 열리는 것을 확인할 수 있다.<br>윈도우 관리도구등 기타 설명은 상단의 유투브 영상을 참고하길 바란다.</p>
<h3 id="Related-Posts"><a href="#Related-Posts" class="headerlink" title="Related Posts"></a>Related Posts</h3>
      
      
          
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>

  
      


  
  
  
  

        
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://www.hanumoka.net/2017/08/31/web-20170831-REST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hanumoka">
      <meta itemprop="description" content="아마추어 개발자의 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hanumoka, IT Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/31/web-20170831-REST/" class="post-title-link" itemprop="url">REST의 정의</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2017-08-31 03:07:34" itemprop="dateCreated datePublished" datetime="2017-08-31T03:07:34+09:00">2017-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-04-16 01:50:12" itemprop="dateModified" datetime="2020-04-16T01:50:12+09:00">2020-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>REST(REpresentational State Transfer: 표현 상태 전송)는 웹 아키텍처 스타일이다.</strong></p>
<p>HTTP 스펙 설계에 참여했던 로이필딩이라는 사람이 2000년대 발표한 네트워크(웹) 아키텍처 스타일이다.<br>여기서 네트워크 아키텍처 스타일이란 한가지의 웹 아키텍쳐 가 아니라 여러 가지 복수의 아키텍쳐의 공통된 성질, 양식 규정 혹은 독특항 방식의 집합을 네트워크 아키텍쳐 스타일이라고 한다.<br>REST를 네트워크 아키텍쳐 스타일이라고 하지만, 사실 HTTP 기반위에 존재하는 아키텍쳐 스타일이므로 웹 아키텍처 스타일이라고 부르는 것도 틀린 표현은 아닌 것 같다.</p>
<p>RESTful은 어떤 대상이 REST 의 제약에 따르고 있고, 그래서 상당히 REST스럽다? REST답다 라는 형용사적 의미이다.</p>
<p>예를 들어 어떤 서버 A가 존재 한다고 하자. 이 A서버는 REST라는 아키텍츠 스타일의 제약을 충실히 따르고 있다면, 이 A 서버를 RESTful 한 서버라 부를 수 있다.</p>
<blockquote>
<p><img src="/images/20170831-REST%EB%9E%80_1.png" alt></p>
</blockquote>
<p><strong>REST의 의미</strong></p>
<blockquote>
<p>REST는 수많은 아키텍처 스타일 중에서도, 특히 네트워크 시스템의 아키텍처 스타일 이다.<br>그리고 REST는 웹의 대표적인 아키택처 스타일인 클라이언트/서버를 기반으로 하는 복합 아키텍처 스타일이다.<br>, 즉 로이필딩은 REST 기반으로 네트워크를 설계하면 효과적이라고 생각했다.</p>
</blockquote>
<p><strong>REST = 클라이언트/서버 + 스테이트리스 서버(Stateless Server) + 캐시(cache) + 유니폼 인터페이스(uniform Interface) + 계층화 시스템 + 코드 온 디맨</strong></p>
<p><strong>클라이언트/서버</strong><br>말그대로 클라이언트 와 서버로 구성되어 있으며 클라이언트에서 request하면 서버에서 response한다.</p>
<p><strong>스테이트리스 서버</strong><br>클라이언트의 어플리케이션 상태를 서버에서 관리하지 않는다는 의미이다. 서버가 어플리케이션의 상태를 가지지 않게되면, 그만큼 서버 측의 구현이 갈결해지는 장점이 있다.<br>하지만 현실적으로 스테이트리스가 아닌 웹 서비스와 웹 API가 많이 사용된다. 특히 HTTP를 스테이트풀 하게 만드는 대표적인 것은 Cookie를 사용한 세션관리이다.<br>REST의 관점에서 본다면, Cookie를 사용한 세션관리는 HTTP의 잘못된 확장이다. 다만 REST의 기준으로 잘못되었다고 해서, Cookie를 사용한 폼 인증을 그만둘 수 없는 것도 현실이다. Cookie는 스테이트리스 서버의 이점을 버린다는 것을 이해한 후 최소한으로 이용 해야 한다.</p>
<p><strong>캐시</strong><br>리소스의 신선도에 기초해, 한번 가져온 리소스를 클라이언트 쪽에서 돌려쓰는 방식.</p>
<p><strong>유니폼 인터페이스 (리소스, http 메소드, 메세지)</strong><br>URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말한다.<br>예를 들어 HTTP1.1 에서 GET, POST등 8개의 메소드만 정의되어 있고, 보통은 이 이상 늘어나지 않는다. 어떻게 보면 확장성이 떨어진다고 보여지지만 이런 제약이 현재 웹의 통일된 인터페이스를 만들어 낸 것이다.</p>
<p>REST에서는 모든 것을 명사형 리소스로 표현하며, 의미가 명확한 한정된 HTTP 메소드를 사요하고, 메세지를 담아서 통신한다.<br>아래는 대표적으로 사용하는 메소드 4개이다.</p>
<table>
<tr><td>메소드명</td><td>기능</td></tr>
<tr><td>get</td><td>search</td></tr>
<tr><td>post</td><td>create</td></tr>
<tr><td>put</td><td>update</td></tr>
<tr><td>delete</td><td>delete</td></tr>
</table>


<p>아래는 실제 REST 메세지의 표현 형테이다.<br><a href="http://somthingweb/user/" target="_blank" rel="external nofollow noopener noreferrer">http://somthingweb/user/</a> 주소(리소스 url)에 POST(CREATE)해라 rocky라는 이름으 user를 이라는 의미를 갖는 메세지이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP POST , http:&#x2F;&#x2F;somthingweb&#x2F;user&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">   &quot;user&quot;:&#123;</span><br><span class="line">       &quot;name&quot;:&quot;rocky&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>계층화 시스템</strong></p>
<p>유니폼 인터페이스로 인해 발생되는 이점중 하나이다. 통일된 인터페이스로 인해 시스템 전체를 계층화 하기 쉽다. 프록시 서버, 로드벨런서 등등을 http 인터페이스로 통일하여 계층화 하여 사용 할수 있다.</p>
<p><strong>코드 온 디맨드(code on demand)</strong></p>
<p>프로그램 코드를 서버에서 다운 받아 클라이언트에서 실행하는 아키텍처 스타일이다.<br>처음에 이 개념은 서버에서 발생하는 부하를 클라이언트쪽으로 부담시켜 서버의 부하를 낮추것이 목적이었다.</p>
<p>예를 들어 javascript나 flash, java 애플릿 등이 여기에 해당한다.<br>반대로 jsp, asp 같이 백엔드에서 페이지를 렌더링해서 클라이언트에 보내는 경우, 수많은 화면 페이지들은  *.jsp 또는 *.asp 이런 확장자를 가지게 된다. 이는 화면단 소스가 백엔드 기술에 종속된다는 것을 의미한다.<br>jsp, asp 이런 기술들은 백엔드에 프론트엔드가 기술적으로 종속된다는 단점이 있지만, 이런 단점을 무색하게 할 정도로 강력한 기능을 제공해 왔다.</p>
<p>하지만 근래 javascript의 눈부신 발달, jquery, ajax 기타 수많은 블라블라.js 등으로 인해 이런 백엔드 서버페이지 기술, jsp, asp이런 것들이 제공하는 기술들을 대체하는 시대가 되었다. 본래의 서버의 부하를 낮추는 기능 뿐만 아니라 프론트 엔드가 서버에 독립적으로 동작할수 있는 특성이 생겨버렸다.</p>
<p>요즘의 REST, RESTful 하다라는 말이 유행하게 된 가장 큰 이유는 발전된 javascript, jquery, ajax를 통해 백엔드에 독립적인 프론트엔드 개발이 가능한 환경 즉 코드 온 디멘드가 가능한 환경이 되었기 때문이라고 생각된다.<br>특히 ajax통신은 http + xml or json 형태의 통신형태로 인해 REST가 지향하는 유니폼 인터페이스를 구현하는 기반이 되었다고 생각된다.</p>
<p>jquery, ajax를 이용하여 프론트엔드는 백엔드에 종속되지 않고 백엔드 시스템과 통신할수 있다.<br>이런 시점에서 적절한 웹 아키텍처가 필요했고 로이필딩이 2000년대 논문을 통해 발표한 REST라는 웹 아키텍처 스타일이 트랜드상 선호되는것 같다.</p>

      
      
          
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>

  
      


  
  
  
  

        
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://www.hanumoka.net/2017/08/31/javascript-20170831-javascript-closure-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hanumoka">
      <meta itemprop="description" content="아마추어 개발자의 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hanumoka, IT Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/31/javascript-20170831-javascript-closure-3/" class="post-title-link" itemprop="url">javascript 클로저(closure)사용시 주의사항(3편)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2017-08-31 03:05:40" itemprop="dateCreated datePublished" datetime="2017-08-31T03:05:40+09:00">2017-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-04-16 01:50:11" itemprop="dateModified" datetime="2020-04-16T01:50:11+09:00">2020-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="클로저-closure-의-사용시-주의사항"><a href="#클로저-closure-의-사용시-주의사항" class="headerlink" title="클로저(closure)의 사용시 주의사항"></a>클로저(closure)의 사용시 주의사항</h2><p>클로저는 그 기묘한 특성?상 다양한 활용이 가능하지만, 무분별하게 사용시 성능문제나 코드의 난독화가 발생한다고 한다.<br>이번글에서는 클로저 사용시 결과 예측을 실수 할수있는 ,즉 헷갈리는 클로저 예제 소스를 통해서 주의할 점을 알아보도록 하겠다.</p>
<p>1.클로저를 선언하는 외부함수의 유효범위 스코프는 클로저에 의해 변경이 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunc</span>(<span class="params">argNum</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> num = argNum;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">	num += x;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'num:'</span> + num);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exam = outerFunc(<span class="number">40</span>);</span><br><span class="line">exam(<span class="number">5</span>);</span><br><span class="line">exam(<span class="number">-10</span>);</span><br></pre></td></tr></table></figure>

<p><strong>결과</strong></p>
<blockquote>
<ul>
<li>num:45</li>
<li>num:35</li>
</ul>
</blockquote>
<p>사실 주의할 점 까지는 아니지만, 클로저의 가장 중요한 개념이다.<br>클로저를 처음 접할때 가장 햇갈리는 부분이 이부분일 것이다.</p>
<p>클로저는 살아있다(alive)! 이 말이 무엇이냐면, outerFunc(40); 로 외부함수는 호출되고 종료되었지만, exam 이라는 변수에 클로저가 생성되고 할당 되었다.<br>이 클로저 exam 이 존재 하기 때문에 자바스크립트 엔진은 exam 이 생성될 때, 접근할 수 있는 영역에 대한 부분을 메모리에서 지우지 않고 보존하고 있다. 즉 exam 은 자신을 생성한 outerFunc의 살아있는 유효범위 스코프에 접근하여 값 접근 및 할당이 가능하다.</p>
<ol start="2">
<li>하나의 클로저가 여러 함수 객체의 스코프 체인에 들어가 있는 경우도 있다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		func1 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(++x); &#125;,</span><br><span class="line">		func2 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(-x); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exam = func();</span><br><span class="line">exam.func1();</span><br><span class="line">exam.func2();</span><br></pre></td></tr></table></figure>

<p><strong>결과</strong></p>
<blockquote>
<ul>
<li>2</li>
<li>-2</li>
</ul>
</blockquote>
<p>이 예제도 그렇게 어려운 예제는 아닐 것이다.<br>func()함수가 호출되며 하나의 객체를 리턴하고 그 객체는 func1, func2 두개의 메소드를 가지고 있다.<br>여기서 헷갈릴 가능성이 있는 부분은 리턴한 객체 exam 의 func1과 func2이 각각 다른 x에 접근 할 것이라 생각 할 수도 있다.<br>결과를 확인하면 exam.func1, 과 exam.func2과 동일한 x를 접근 하는 것을 확인 할 수 있다.</p>
<p>func1과 func2는 [동일한 함수 호출]에 의해 만들어 졌기 때문에 같은 x[동일한 함수 호출의 유효범위 스코프]에 접근 하는 것이다.</p>
<p>2번 예제를 통해 한가지 더 모호한 점은 클로저라는 어떤 대상의 구분이다.</p>
<p><img src="/images/2017-06-11-javascript7_1.png" alt></p>
<p>한개의 클로저의 범위를 정의 한다면, 한개의 외부함수의 유효범위 스코프와 그 유효범위 스코프를 공유하는 내부함수(1개 이상)라고 볼 수 있을것 같다.</p>
<p>3.클로저를 정의하는 함수 내에서 루프를 이용하는 경우</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constfuncs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> funcs = [];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">	funcs[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> i;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> funcs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funcs = constfuncs();</span><br><span class="line">funcs[<span class="number">0</span>]();</span><br><span class="line">funcs[<span class="number">4</span>]();</span><br><span class="line">funcs[<span class="number">9</span>]();</span><br></pre></td></tr></table></figure>

<p><strong>결과</strong></p>
<blockquote>
<ul>
<li>10</li>
<li>10</li>
<li>10</li>
</ul>
</blockquote>
<p>결과를 0, 4, 9 가 리턴 될 것이라 예측 할 수도 있다. (필자 역시…)<br>여기서 중요한 점은 클로저와 연관된 유효범위 체인이 ‘살아있다’라는 것이다.<br>중첩함수의 유효범위에 대한 내부 사본이나 변수 바인딩의 스냅샷은 만들어지지 않는다.<br>이미 funcs<a href>0</a> 이 호출되는 시점에는 자신을 생성할 때 호출된 constFuncs 함수의 var i 는 for문이 완벽하게 동작하고 종료되었기 때문에 10인 것이다.</p>
<ol start="4">
<li>this와 arguments 사용시 주의점</li>
</ol>
<p>이 부분은 클로저 사용시 주의사항이라기 보다는 내부함수(중첩함수) 사용시 공통적으로 주의해야 할 부분이다.</p>
<p>모든 함수 호출에는 this값이 있고, 외부 함수가 this 값을 별도로 변수로 저장하지 않으면 클로저는 외부 함수의 this값에 접근 할 수 없다.<br>arguments는 키워드는 아니지만, 모든 함수 호출에 자동으로 선언된다. 클로저 함수는 자신만의 arguments를 가지고 있기 때문에, 외부 함수가 argumengs을 다른 이름의 변수에 저장하지 않는 한, 클로저는 외부 함수의 arguments에 접근 할 수없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunc1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.dir(<span class="keyword">this</span>);</span><br><span class="line">	<span class="built_in">console</span>.dir(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">	"use strict"</span>;    <span class="comment">// this가 Window 전역객체로 할당 되는것을 강제로 막았다.</span></span><br><span class="line">        <span class="built_in">console</span>.dir(<span class="keyword">this</span>);</span><br><span class="line">	<span class="built_in">console</span>.dir(<span class="built_in">arguments</span> );</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test1 = outerFunc1(<span class="number">111</span>, <span class="string">'가나다'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/images/2017-06-11-javascript7_3.png" alt></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test1();</span><br></pre></td></tr></table></figure>
<p><img src="/images/2017-06-11-javascript7_4.png" alt></p>
<p>리턴된 클로저를 호출시 this 는 undefined(use strict를 통해 강제로 막았기 때문에) 그리고 arguments객체는 존재는 하지만 클로저 자신이 호출될때 생성된 arguments이기 때문에 외부함수 outerFunc1의 arguments에는 접근 할 수 없다.</p>
<p>해결방법 외부함수의 this와 arguments 객체를 외부함수 지역변수에 할당하자!</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFunc2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.dir(<span class="keyword">this</span>);</span><br><span class="line">	<span class="built_in">console</span>.dir(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> outThis = <span class="keyword">this</span>;       <span class="comment">// this를 클로저가 접근할 수 있도록 지역변수에 할당한다.</span></span><br><span class="line">	<span class="keyword">var</span> outArgu = <span class="built_in">arguments</span>;  <span class="comment">// arguments를 클로저가 접근할 수 있도록 지역변수에 할당한다.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">console</span>.dir(outThis);</span><br><span class="line">	   <span class="built_in">console</span>.dir(outArgu );</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test2 = outerFunc2(<span class="number">222</span>, <span class="string">'abc'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/images/2017-06-11-javascript7_5.png" alt></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test2();</span><br></pre></td></tr></table></figure>

<p><img src="/images/2017-06-11-javascript7_6.png" alt></p>
<p>외부함수의 this 와 arguments 를 지역변수에 할당하여 클로저가 접근할 수 있도록 할 수 있다.</p>

      
      
          
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>

  
      


  
  
  
  

        
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://www.hanumoka.net/2017/08/31/javascript-20170831-javascript-closure-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hanumoka">
      <meta itemprop="description" content="아마추어 개발자의 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hanumoka, IT Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/31/javascript-20170831-javascript-closure-2/" class="post-title-link" itemprop="url">javascript 클로저(closure)의 활용(2편)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2017-08-31 03:04:57" itemprop="dateCreated datePublished" datetime="2017-08-31T03:04:57+09:00">2017-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-04-16 01:50:11" itemprop="dateModified" datetime="2020-04-16T01:50:11+09:00">2020-04-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="클로저-closure-의-활용"><a href="#클로저-closure-의-활용" class="headerlink" title="클로저(closure)의 활용"></a>클로저(closure)의 활용</h2><p>본 글은 독자가 자바스크립트 클로저의 개념에 대한 이해를 전제하에 작성된 글이다.</p>
<p>자바스크립트의 클로저의 개념에 대해서는 공부를 했지만, 막상 이 클로저라는 것을 활용해 보려니 도통 감이 오질 않는다.<br>클로저를 활용한다는 말인 즉, 클로저를 통해서 어떤 프로그래밍 적 효과를 발생시키고 그 효과를 활용 한다는 말일 것이다.</p>
<p>그렇다면 간단한 예제를 통해 그 효과와 그 효과를 활용하는 방법을 알아보자.<br>(클로저는 성능적인 면과 자원적인 면에서 약간 손해를 볼수 있으므로 무차별적으로 사용해서는 안된다고 한다.)</p>
<h3 id="활용1-함수-캡슐화"><a href="#활용1-함수-캡슐화" class="headerlink" title="활용1 - 함수 캡슐화"></a>활용1 - 함수 캡슐화</h3><p>설명 할 클로저는 함수형 프로그래밍 기법이지만, 캡슐화를 구현할 수 있다.<br>캡슐화란 객체지향 프로그래밍의 하나의 개념 중 하나이다.<br>객체지향 프로그래밍의 캡슐화란 다음과 같다.</p>
<p>캡슐화란?</p>
<blockquote>
<p>객체의 속성(data fileds)과 행위(메소드, methods)를 하나도 묶는다.<br>실제 구현 내용 일부를 외부에 감추어 은닉한다.</p>
</blockquote>
<p>하지만 자바스크립트에서 기본적인 객체선언은 캡슐화의 두번째 측면인 실제 구현내용을 외부에 감추어 은닉할수가 없다.<br>간단한 객체 리터럴 예제로 확인해보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countObj1 = &#123;</span><br><span class="line">	n : <span class="number">0</span>,</span><br><span class="line">	count : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.n++;&#125;,</span><br><span class="line">        reset : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">this</span>.n = <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>countObj1객체의 의도는 메소드 count를 이용해서 n을 1씩 증가시키는 것이다.<br>그리고 reset 메소드를 이용하여 n을 0로 초기화 시킨다.</p>
<p><img src="/images/2017-06-11-javascript6_1.png" alt></p>
<p>그리고 위처럼 사용 할수 있다. 하지만 객체의 내부 프로퍼티인 n을 다른 방식으로 접근하여 호출 또는 재정의 할 수 있다.</p>
<p><img src="/images/2017-06-11-javascript6_2.png" alt></p>
<p>위처럼 내부 객체의 내부 프로퍼티에 직접 접근하여 재 할당 될 수 있다.<br>만약 악의적인 코드 또는 실수로 인해 외부에서 직접 n을 접근 할 경우 의도치 않은 동작을 할 수도 있다.</p>
<p>이렇게 외부에서 임의로 데이터를 접근 또는 훼손하는 것을 막는 기법이 캡슐화의 데이터 은닉이다.<br>하지만 안타깝게도 자바스크립트에서는 문법적으로 캡슐화의 데이터 은닉를 지원하지 않는다.  (java, c++에서는 문법적으로 지원한다.)</p>
<p>이 캡슐화의 데이터 은닉을 자바스크립트에서는 함수형 프로그래밍 기법인 클로저를 이용해 구현 할 수 있다.</p>
<p>1번 예제에 클로저를 적용하여 내부 변수 n을 외부에서 접근 못하게 해보자.(캡슐화의 데이터은닉)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		count: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> n++; &#125;,</span><br><span class="line">                reset: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; n = <span class="number">0</span>; &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> countA = counter();</span><br><span class="line"><span class="keyword">var</span> countB = counter();</span><br></pre></td></tr></table></figure>

<p><img src="/images/2017-06-11-javascript6_3.png" alt></p>
<p>위 소스코드에서는 counter 함수가 리턴하는 객체의 메소드 count()와 reset()가 클로저가 된다. (이부분이 이해가 안간다면 클로저의 개념과 대해 다시 공부해야 한다.)</p>
<p>2번 예제는 1번예제와 객체 생성방법이 다르지만, 만들어진 객체의 사용은 동일하다.<br>count 메소드를 이용하여 n에 1을 더하고 , reset 메소드를 이용하여 n을 0으로 초기화 하고 있다.</p>
<p>그렇다면 2번예제에서도 1번예제처럼 직접 객체에 접근하여 n을 수정해 보자.</p>
<p><img src="/images/2017-06-11-javascript6_4.png" alt></p>
<p>countA.n = 100; 을 통해 n이라는 객체에 새로운 변수를 추가 할 수 있다.<br>하지만 countA의 메소드(클로저)는 이 countA의 멤버변수 n을 사용하는 것이 아니라 자기 자신의 외부함수 counter의 지역변수 n을 사용하기 때문에 객체의 메소드를 호출시 계획한 대로 결과가 나오는 것을 확인 할수있다.<br>이것은 클로저를 통해 변수 n이 은닉되어 있기때문에 가능한 결과이다.</p>
<p>2번 예제를 이용해 클로저에 대한 부연설명을 조금 더 해보자면,<br>countA.count()와 countA.reset() 메소드는 하나의 n을 공유한다.<br>하지만 countA 와 countB는 n을 공유하지 않고 각각의 n을 사용한다.<br>counter함수가 호출되어 새로운 객체를 리턴 할 때마다 새로운 유효범위 체인과 새로운 내부변수(n)이 생성되기 때문이다.<br>여기서 이 counter의 내부변수 n이 캡슐화된 외부로부터 은닉된 실제 구현내용이 된다.<br>이런 캡슐화를 통해서 내부변수 n이 외부로 부터 오염되는 것을 막을수 있다.</p>
<h3 id="활용2-함수의-호출방법의-가공"><a href="#활용2-함수의-호출방법의-가공" class="headerlink" title="활용2 - 함수의 호출방법의 가공"></a>활용2 - 함수의 호출방법의 가공</h3><p>setTimeout  함수는 첫번째 인자로 받는 함수 참조값을 특정시간(두번째 인자) 이후에 실행시키는 내장함수이다.<br>문제는 첫번째 인자로 넘기는 함수에 매개변수를 전달 할 수 없다는 것이다.<br>하지만 클로저를 이용해 전달할 함수를 클로저로 변환하여 호출하는 방법을 가공 할수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"%d + %d = %d"</span>, a, b, a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callLater</span>(<span class="params">func, a, b</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tempFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        func(a, b)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tempFn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = callLater(sum, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">setTimeout(func, <span class="number">8000</span>);</span><br></pre></td></tr></table></figure>


<p>간단한 예제이다. callLater 함수를 이용해 setTimeout에게 전달할 함수의 호출환경을 미리 설정해 놓고 그것을 클로저(tempFn)로 만들어 func 변수에 할당했다.<br>func 클로저는 인자가 필요 없으므로 setTimeout에 첫번째 인자로 전달할 수 있다.</p>
<p>자바스크립트에서는 함수도 일급객체이므로 변수처럼 다른 함수의 인자로 전달하여 실행시키는 경우가 많은데, 전달할 인자 함수에 매개변수를 클로저를 통해 미리 조립하여 전달하는 방식으로 클로저를 사용 할 수 있다.</p>
<p>클로저의 활용 방법을 간단한  2가지 예로 설명했는데, 사실 더 다양한 방법이 있을 것이다.<br>스스로 더 공부하고 코딩하면서 클로저의 다양한 활용방법을 찾아보길 바란다.</p>

      
      
          
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>

  
      


  
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/"><i class="fa fa-angle-left" aria-label="이전 페이지"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/20/"><i class="fa fa-angle-right" aria-label="다음 페이지"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          목차
        </li>
        <li class="sidebar-nav-overview">
          흝어보기
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hanumoka</p>
  <div class="site-description" itemprop="description">아마추어 개발자의 블로그</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">196</span>
          <span class="site-state-item-name">포스트</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">카테고리</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">551</span>
        <span class="site-state-item-name">태그</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hanumoka" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hanumoka" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:amagramer@gmail.com" title="E-Mail → mailto:amagramer@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>


    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hanumoka</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
